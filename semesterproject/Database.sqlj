/*
 * file: Database.sqlj
 *
 * Originally written by Russell C. Bjork
 * Modified for CS352 Project by: Jake Colbert and Eddy Botelho (team 6)
 *
 */

package semesterproject;

import semesterproject.gui.ErrorMessage;
import java.io.PrintStream;
import java.util.Calendar;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.sql.*;
import java.math.BigDecimal;
import sqlj.runtime.*;
import sqlj.runtime.ref.*;

//Added these to calculate daysLate in return method
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

/**
 * This class manages access to the database for the CS352 Library project
 */

public class Database
{
    /** Constructor
     *
     */
    public Database() throws Exception
    {
        // Load the db2 driver

        try
        {
            Class.forName(DRIVER_NAME).newInstance();
        }
        catch(Exception e)
        {
            System.err.println("Error loading db2 driver " + e);
            if (e instanceof SQLException)
                System.err.println("Code: " + ((SQLException) e).getErrorCode()
                    + "State: " + ((SQLException) e).getSQLState());
            throw e;
        }
    }

    /* *************************************************************************
     * THE FOLLOWING METHODS ARE CALLED WHEN VARIOUS OPERATIONS ARE SELECTED
     * BY THE USER IN THE GUI.
     * ************************************************************************/

    /** Method used to login to the database - called when user enters a
     *  username and password and clicks OK.  For testing / evaluation, the
     *  special username "none" is recognized (and does not need a password). As
     *  a username, "none" means proceed without establishing a connection to the
     *  database - usable only for demonstrating the GUI without actually
     *  accessing the database, of course.
     *
     *  @param username the username the user typed
     *  @param password the password the user typed
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the login fails
     */
    public void login(String username, char [] password) throws ErrorMessage
    {
        connection = null;
        try
        {
            if (! username.equals("none"))
            {
                connection = DriverManager.getConnection(DATABASE_URL,
                                    username, new String(password));
                DefaultContext context = new DefaultContext(connection);
                DefaultContext.setDefaultContext(context);
                connection.setAutoCommit(false);
        		resetToday();
            }
        }
        catch(SQLException e)
        {
            if (e.getErrorCode() == BAD_PASSWORD_SQL_ERROR)
                throw new ErrorMessage("Incorrect username and/or password");
            else
            {
                throw new ErrorMessage("Unexpected SQL error: " + e.getMessage() +
                      "Code: " + e.getErrorCode() + " State: " + e.getSQLState());
            }
        }
        finally
        {
            for (int i = 0; i < password.length; i ++)
                password[i] = 0;
        }
    }

	/* ************************************************************************
	 * Method called to delete all existing entries in the database
	 * ************************************************************************

	 /** Delete all existing entries in the database
	  */
	public void startOver() throws ErrorMessage
	{
		try
		{
			#sql { delete from fine where true };
			#sql { delete from checked_out where true };
			#sql { delete from book_keyword where true };
			#sql { delete from book_author where true };
			#sql { delete from book where true };
			#sql { delete from book_info where true };
			#sql { delete from borrower_phone where true };
			#sql { delete from borrower where true };
			#sql { delete from category where true };
			#sql { commit };
		}
        catch(SQLException e)
        {
            rollback();
        	throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /* ************************************************************************
     * Methods called to perform check-out, check-in, and renewal of books.
     * ***********************************************************************/

    /** Get the name of a borrower, given his/her ID
     *
     *  @param borrowerID the ID of the borrower.
     *  @return this borrower's name
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the borrower does not exist
     */
    public String getBorrowerName(String borrowerID) throws ErrorMessage
    {
// IMPLEMENTED STUB (Implemented by EB)
        String b_first, b_last, b_name = null;
        try {
            #sql { SELECT first_name, last_name
                   INTO :b_first, :b_last
                   FROM Borrower WHERE borrower_id = :borrowerID };
            #sql { commit };

        } catch(SQLException e) {
            rollback();
        	throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        b_name = b_first + ' ' + b_last;
        return b_name;
    }

    /** Check out a book.
     *
     *  @param borrowerID the ID of the borrower to whom book is to be checked
     *         out
     *  @param callNumber the call number of the book to check out
     *  @param copyNumber the copy number of the book to check out
     *  @return the date on which the book will be due
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the check out fails
     */
    public Date checkOutBook(String borrowerID,
                             String callNumber,
                             short copyNumber) throws ErrorMessage
    {
// IMPLEMENTED STUB (Implemented by EB)
        //First we must figure out the borrower's check-out period
        int b_checkout_period = 0;
        try {
            #sql { SELECT checkout_period
                   into :b_checkout_period
                   FROM Borrower JOIN Category ON Borrower.category_name =
                   Category.category_name
                   WHERE borrower_id = :borrowerID};
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            if (e.getMessage().contains("no rows found for select into statement")) {
                throw new ErrorMessage(NO_SUCH_BORROWER);
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }

        //Now we get date due as current date + b_checkout_period
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, b_checkout_period);
        Date dateDue = new Date(calendar.getTime().getTime());

        try {
            #sql { INSERT into Checked_out(
                call_number, copy_number, borrower_id, date_due)
                values (:callNumber, :copyNumber, :borrowerID, :dateDue)};
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            if (e.getMessage().contains("SQLERRMC=MAX_BOOKS_ALREADY_OUT")) {
                throw new ErrorMessage(MAX_BOOKS_ALREADY_OUT_MSG);
            } else if (e.getErrorCode() == DUPLICATE_KEY_SQL_ERROR) {
                throw new ErrorMessage(DUPLICATE_ENTRY_ERROR);
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }
        return dateDue;
    }

    /** Return a book.  If an overdue fine is incurred, it will be recorded
     *  in the database.
     *
     *  @param callNumber the call number of the book to return
     *  @param copyNumber the copy number of the book to return
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the return fails.  If a fine is incurred, an ErrorMessage is
     *          also thrown reporting this fact after the fine is recorded in
     *          the database
     */
    public void returnBook(String callNumber, short copyNumber) throws ErrorMessage
    {
// IMPLEMENTED STUB (Implemented by EB)
        //First we must get the date due to see if the book is overdue
        Date dateDue = null;
        try {
            #sql {  SELECT date_due
                    INTO :dateDue
                    FROM Checked_out
                    WHERE call_number = :callNumber AND
                     copy_number = :copyNumber };
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            if (e.getMessage().contains("no rows found for select into statement")) {
                throw new ErrorMessage(NO_SUCH_BOOK + " in the Checked_out table.");
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }

        // daysLate is then calculated from the checkout record in the database
        // Get current date (SHOULD THIS BE SOME CONSTANT "TODAY"??)
        Calendar calendar = Calendar.getInstance();
        Date currentDate = new Date(calendar.getTime().getTime());

        // Convert dates to proper format for comparison, then calculate
        long millisecondsLate = currentDate.getTime() - dateDue.getTime();
        int daysLate = (int) (millisecondsLate / (1000 * 60 * 60 * 24));

        // Delete the actual checked_out entry
        try {
            #sql {  DELETE FROM Checked_out
                    WHERE call_number = :callNumber AND
                        copy_number = :copyNumber };
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }

        //If the book was late
        if (daysLate > 0) {
            // Calculate fine amount for the sake of displaying to the GUI
            BigDecimal fineAmount =
                new BigDecimal(Fine.DAILY_FINE_RATE * .01 * daysLate).
            setScale(2, BigDecimal.ROUND_HALF_UP);

            throw new ErrorMessage("Book is overdue " + daysLate + " days " +
                "- a fine of $" + fineAmount + " has been assessed");
        }
    }

    /** Renew a book  If there is any problem, an appropriate error
     *  message will be displayed before returning to the caller.
     *
     *  @param callNumber the call number of the book to renew
     *  @param copyNumber the copy number of the book to renew
     *  @return the date on which the book will be due if renewed succssfully
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the renewal fails for any reason.
     */
    public Date renewBook(String callNumber, short copyNumber) throws ErrorMessage
    {
// IMPLEMENTED STUB (Implemented by EB)
        // First we must get the date due
        Date dateDue = null;
        try {
            #sql {  SELECT date_due
                    INTO :dateDue
                    FROM Checked_out
                    WHERE call_number = :callNumber AND
                    copy_number = :copyNumber };
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            if (e.getMessage().contains("no rows found for select into statement")) {
                throw new ErrorMessage(NO_SUCH_BOOK + " in the Checked_out table.");
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }

        // Then we need to get the borrower's checkout period
        int b_checkout_period = 0;
        try {
            #sql { SELECT checkout_period
                   into :b_checkout_period
                   FROM Checked_out JOIN Borrower
                   ON Checked_out.borrower_id = Borrower.borrower_id
                   JOIN Category
                   ON Borrower.category_name = Category.category_name
                   WHERE call_number = :callNumber
                   AND copy_number = :copyNumber};
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            if (e.getMessage().contains("no rows found for select into statement")) {
                throw new ErrorMessage(NO_SUCH_BORROWER);
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }

        // Calculate the new due date
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(dateDue);
        calendar.add(calendar.DATE, b_checkout_period);
        Date newDueDate = new Date(calendar.getTime().getTime());

        // Now we go ahead and renew the book in the database
        try {
            #sql {  UPDATE Checked_out
                    SET (date_due) = :newDueDate
                    WHERE call_number = :callNumber
                    AND copy_number = :copyNumber };
            #sql { commit };
        } catch(SQLException e) {
            rollback();
            if (e.getMessage().contains("CANT_RENEW_OVERDUE")) {
                throw new ErrorMessage(CANT_RENEW_OVERDUE_MSG);
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }
        return newDueDate;
    }

    /* ************************************************************************
     * Methods that support adding/editing/deleting entities.  In most cases,
     * some access to existing information in the database is needed before
     * the user can be asked for all the information needed for the change.
     * ***********************************************************************/

    /** Determine whether or not a book with a given call number already exists
     *
     *  @param callNumber the call number of a book
     *  @return true if an entry exists in the database for this call number
     */
    public boolean bookExists(String callNumber) throws ErrorMessage
    {
        int count = 0;
        try
        {
            #sql { select count(*)
                    into :count
                    from Book_info
                    where call_number = :callNumber
                 };
        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }

        return count > 0;
    }

    /** Add a new book to the database.
     *
     *  @param callNumber the call number of the book to add
     *  // The remaining parameters are null when adding a new copy of an existing
     *  // book
     *  @param title the title of the book
     *  @param authors the authors of the book (a List whose elements are strings
     *                 corresponding to the various authors)
     *  @param format the format of the book
     *  @param keywords the keywords of the book (a List whose elements are strings
     *                 corresponding to the various keywords)
     *  // Note that the copy number and bar code are not passed as
     *  // parameters.  The copy number will be 1 if there is no existing
     *  // book of this call number - else 1 more than the highest existing
     *  // number.  The bar code will be generated automatically
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void addBook(String callNumber, String title, List authors,
                        String format, List keywords) throws ErrorMessage
    {
        try
        {
            if (title == null)
            {
                // New copy of an existing book

                #sql { insert into Book(call_number, copy_number)
                        values (:callNumber,
                                1 + (select max(copy_number)
                                        from Book
                                        where call_number = :callNumber))
                     };

                #sql { commit };
            }
            else
            {
                // Totally new book

                #sql { insert into Book_info
                        values (:callNumber, :title, :format)
                     };

                Iterator authorIterator = authors.iterator();
                while (authorIterator.hasNext())
                {
                    String author = (String) authorIterator.next();

                    #sql { insert into Book_author
                            values(:callNumber, :author)
                         };
                }

                Iterator keywordIterator = keywords.iterator();
                while (keywordIterator.hasNext())
                {
                    String keyword = (String) keywordIterator.next();

                    #sql { insert into Book_keyword
                            values(:callNumber, :keyword)
                         };
                }

                #sql { insert into Book(call_number, copy_number)
                        values (:callNumber, 1)
                     };

                #sql { commit };
            }
        }
        catch(SQLException e)
        {
            rollback();
            if (e.getErrorCode() == DUPLICATE_KEY_SQL_ERROR)
            {
                // A primary key violation cannot occur for the Book table
                // or for the Book_info table, so it must be for the author
                // or keyword table
                if (e.getMessage().indexOf(BOOK_AUTHOR_TABLE_NAME) >= 0)
                    throw new ErrorMessage("Duplicate author for this book");
                else
                    throw new ErrorMessage("Duplicate keyword for this book");
            }
            else if (e.getMessage().indexOf(BOOK_INFO_VALID_FORMAT_CONSTRAINT) >= 0)
                throw new ErrorMessage("Invalid format");
            else if (e.getMessage().indexOf(BOOK_KEYWORD_VALID_KEYWORD_CONSTRAINT) >= 0)
                throw new ErrorMessage("A keyword contains a space");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Get information on an existing book about to be edited
     *
     *  @param callNumber the call number of the book
     *  @return values recorded in the database for this book.  A single
     *          valued attribute has its value represented as a string; a
     *          multi-valued attribute has its value represented as a
     *          List whose elements are strings representing the various values
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the book does not exist
     */
    #sql iterator BookInfoCursor(String);

    public Object[] getBookInformation(String callNumber) throws ErrorMessage
    {
        List originalAuthors = new ArrayList();
        List originalKeywords = new ArrayList();
        Object[] values = new Object[7];
        values[0] = callNumber;
        values[1] = "(information applies to all copies of this book)";
        values[2] = "(information applies to all copies of this book)";
        try
        {
            String title = null, format = null;

            #sql { select title, format
                    into :title, :format
                    from Book_info
                    where call_number = :callNumber
                 };

            values[3] = title;
            values[5] = format;

            BookInfoCursor cursor;

            #sql cursor = { select author_name
                                from Book_author
                                where call_number = :callNumber
                          };

            String author = null;

            while(true)
            {
                #sql { fetch :cursor into :author
                     };

                if (cursor.endFetch()) break;

                originalAuthors.add(author);
            }

            values[4] = originalAuthors;

            #sql cursor = { select keyword
                                from Book_keyword
                                where call_number = :callNumber
                          };

            String keyword = null;

            while(true)
            {
                #sql { fetch :cursor into :keyword
                     };

                if (cursor.endFetch()) break;

                originalKeywords.add(keyword);
            }

            values[6] = originalKeywords;
        }
        catch(SQLException e)
        {
            if (e.getSQLState().equals(NO_ROW_SQL_STATE))
                throw new ErrorMessage("No such book");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }

        return values;
    }

    /** Update stored information about a book
     *
     *  @param callNumber the call number of the book
     *  @param newTitle the new value of the book's title (may be the same as original)
     *  @param originalAuthors the original list of authors for the book
     *         This will be a list of Strings, each the name of one author
     *  @param newAuthors the new list of the book's authors (may be the same as original)
     *         This will be a list of Strings, each the name of one author
     *  @param newFormat the new value of the book's format (may be the same as original)
     *  @param originalKeywords the original list of keywords for the book
     *         This will be a list of Strings, each the name of one author
     *  @param newKeywords the new list of the book's keywords (may be the same as original)
     *         This will be a list of Strings, each one keyword
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void updateBook(String callNumber,
                           String newTitle,
                           List originalAuthors,
                           List newAuthors,
                           String newFormat,
                           List originalKeywords,
                           List newKeywords) throws ErrorMessage
    {
        try
        {
            #sql { update Book_info
                        set title = :newTitle, format = :newFormat
                        where call_number = :callNumber
                 };

			// Remove old list of authors

			#sql { delete from Book_author
							where call_number = :callNumber
				 };

            // Insert new list of authors

            Iterator newAuthorsIterator = newAuthors.iterator();

            while(newAuthorsIterator.hasNext())
            {
                String newAuthor = (String) newAuthorsIterator.next();
				#sql { insert into Book_author
							values(:callNumber, :newAuthor)
					 };
            }

			// Remove old list of keywords

			#sql { delete from Book_keyword
						where call_number = :callNumber
				 };

            // Insert new list of keywords

            Iterator newKeywordsIterator = newKeywords.iterator();

            while(newKeywordsIterator.hasNext())
            {
                String newKeyword = (String) newKeywordsIterator.next();
				#sql { insert into Book_keyword
							values(:callNumber, :newKeyword)
					 };
            }

            #sql { commit };
        }
        catch(SQLException e)
        {
            rollback();
            if (e.getErrorCode() == DUPLICATE_KEY_SQL_ERROR)
            {
                if (e.getMessage().indexOf(BOOK_AUTHOR_TABLE_NAME) >= 0)
                    throw new ErrorMessage("Duplicate author for this book");
                else
                    throw new ErrorMessage("Duplicate keyword for this book");
            }
            else if (e.getMessage().indexOf(BOOK_INFO_VALID_FORMAT_CONSTRAINT) >= 0)
                throw new ErrorMessage("Invalid format");
            else if (e.getMessage().indexOf(BOOK_KEYWORD_VALID_KEYWORD_CONSTRAINT) >= 0)
                throw new ErrorMessage("A keyword contains a space");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Get information on an existing book copy about to be deleted
     *
     *  @param callNumber the call number of the book
     *  @param copyNumber the copy number of the book
     *  @return values recorded in the database for this book.  A single
     *          valued attribute has its value represented as a string; a
     *          multi-valued attribute has its value represented as a
     *          List whose elements are strings representing the various values
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the book does not exist
     */
    public Object[] getBookCopyInformation(String callNumber, short copyNumber)
                                                            throws ErrorMessage
    {
        List originalAuthors = new ArrayList();
        List originalKeywords = new ArrayList();
        Object[] values = new Object[7];
        values[0] = callNumber;
        values[1] = "" + copyNumber;

        try
        {
            short barCode = 0;
            String title = null, format = null;

            #sql { select bar_code, title, format
                    into :barCode, :title, :format
                    from Book join Book_info
                        on Book.call_number = Book_info.call_number
                    where Book.call_number = :callNumber and
                          Book.copy_number = :copyNumber
                 };

            values[2] = "" + barCode;
            values[3] = title;
            values[5] = format;

            BookInfoCursor cursor;

            #sql cursor = { select author_name
                                from Book_author
                                where call_number = :callNumber
                          };

            String author = null;

            while(true)
            {
                #sql { fetch :cursor into :author
                     };

                if (cursor.endFetch()) break;

                originalAuthors.add(author);
            }

            values[4] = originalAuthors;

            #sql cursor = { select keyword
                                from Book_keyword
                                where call_number = :callNumber
                          };

            String keyword = null;

            while(true)
            {
                #sql { fetch :cursor into :keyword
                     };

                if (cursor.endFetch()) break;

                originalKeywords.add(keyword);
            }

            values[6] = originalKeywords;
        }
        catch(SQLException e)
        {
            if (e.getSQLState().equals(NO_ROW_SQL_STATE))
                throw new ErrorMessage("No such book");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }

        return values;
    }

    /** Delete a book
     *
     *  @param callNumber the call number of the book to delete
     *  @param copyNumber the copy number of the book to delete
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void deleteBook(String callNumber, short copyNumber) throws ErrorMessage
    {
        try
        {
            #sql { delete from Book
                        where call_number = :callNumber and
                              copy_number = :copyNumber
                 };

            #sql { commit };
        }
        catch(SQLException e)
        {
            rollback();
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Add a new category to the database.
     *
     *  @param categoryName the name of the category to add
     *  @param checkoutPeriod the period borrowers in this category can check
     *         books out for
     *  @param maxBooksOut the maximum number of books borrowers in this category
     *         can have out
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void addCategory(String categoryName,
                            int checkoutPeriod,
                            int maxBooksOut) throws ErrorMessage
    {
        try
        {
            #sql { insert into category
                        values (:categoryName, :checkoutPeriod, :maxBooksOut)
                 };
            #sql { commit };
        }
        catch(SQLException e)
        {
            rollback();
            if (e.getErrorCode() == DUPLICATE_KEY_SQL_ERROR)
                throw new ErrorMessage(
                    "Category name is the same as an existing category");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Get information on an existing category about to be edited or deleted
     *
     *  @param categoryName the name of the category
     *  @return values recorded in the database for this category - an array
     *          of strings.
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the category does not exist
     */
    public String[] getCategoryInformation(String categoryName) throws ErrorMessage
    {
        String [] values = new String[3];
        values[0] = categoryName;
        int checkoutPeriod, maxBooksOut;
        try
        {
            #sql {  select checkout_period, max_books_out
                        into :checkoutPeriod, :maxBooksOut
                        from category
                        where category_name = :categoryName
                 };
            values[1] = "" + checkoutPeriod;
            values[2] = "" + maxBooksOut;
            return values;
        }
        catch(SQLException e)
        {
            if (e.getSQLState().equals(NO_ROW_SQL_STATE))
                throw new ErrorMessage("No such category");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }
    }

    /** Update stored information about a category
     *
     *  @param categoryName the name of the category
     *  @param newCheckoutPeriod the new value of checkoutPeriod (may be the same
     *         as original)
     *  @param newMaxBooksOut the new value of maxBooksOut (may be the same as original)
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void updateCategory(String categoryName,
                               int newCheckoutPeriod,
                               int newMaxBooksOut) throws ErrorMessage
    {
        try
        {
            #sql { update category
                        set checkout_period = :newCheckoutPeriod,
                            max_books_out = :newMaxBooksOut
                        where category_name = :categoryName
                 };
            #sql { commit };
        }
        catch(SQLException e)
        {
            rollback();
            // Since we found the row when initiating the operation, an error
            // now is always unexpected
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Delete a category
     *
     *  @param categoryName the name of the category to delete
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void deleteCategory(String categoryName) throws ErrorMessage
    {
        try
        {
            #sql { delete from category
                        where category_name = :categoryName
                 };
            #sql { commit };
        }
        catch(SQLException e)
        {
            rollback();
            if (e.getMessage().indexOf(BORROWER_CATEGORY_FOREIGN_CONSTRAINT) >= 0)
                throw new ErrorMessage("There are still borrowers in this category");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Add a new borrower to the database.
     *
     *  @param borrowerID the ID for the borrower
     *  @param lastName the borrower's last name
     *  @param firstName the borrower's first name
     *  @param phones the borrower's phone number(s) - a List of strings, each of
     *         which represents one phone number
     *  @param category the name of the category to which the borrower will belong
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void addBorrower(String borrowerID,
                            String lastName,
                            String firstName,
                            List phones,
                            String category) throws ErrorMessage
    {
// IMPLEMENTED STUB (Implemented by EB)
        try {
            //Insert into borrower table
            #sql { INSERT INTO Borrower
                    values (:borrowerID, :lastName, :firstName, :category)
            };

            //Insert into Borrower_phone table
            Iterator phonesIterator = phones.iterator();
            while(phonesIterator.hasNext()) {

                String number = (String) phonesIterator.next();

                #sql { INSERT INTO Borrower_phone
                        values(:borrowerID, :number)
                };
            }

            #sql { commit };

        } catch(SQLException e) {
            rollback();
            if (e.getErrorCode() == DUPLICATE_KEY_SQL_ERROR) {
                throw new ErrorMessage(DUPLICATE_ENTRY_ERROR);
            } else if (e.getErrorCode() == NON_EXISTENT_PARAMETER) {
                throw new ErrorMessage(BORROWER_CATEGORY_FOREIGN_CONSTRAINT);
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }
    }

    /** Get information on an existing borrower about to be edited or deleted
     *
     *  @param borrowerID the borrower ID of the borrower
     *  @return values recorded in the database for this borrower.  A single
     *          valued attribute has its value represented as a string; a
     *          multi-valued attribute has its value represented as a
     *          List whose elements are strings representing the various values
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the borrower does not exist
     */
     #sql iterator BorrowerPhoneCursor(String);

    public Object [] getBorrowerInformation(String borrowerID) throws ErrorMessage
    {
    // IMPLEMENTED STUB (Implemented by EB)
        List originalPhones = new ArrayList();
        Object [] values = new Object[5];
        values[0] = borrowerID;
        try {
            String last_name = null, first_name = null, category = null;

            //Get the non multivalued stuff and put it in object
            #sql { SELECT last_name, first_name, category_name
                   INTO :last_name, :first_name, :category
                   FROM Borrower
                   WHERE borrower_id = :borrowerID };

            values[1] = last_name;
            values[2] = first_name;
            values[3] = category;

            //Get the multivalued stuff
            BorrowerPhoneCursor cursor;

            #sql cursor = {
                SELECT phone
                FROM Borrower_phone
                WHERE borrower_id = :borrowerID
            };

            String phone = null;
            while(true) {
                #sql { fetch :cursor into :phone };

                if (cursor.endFetch())
                    break;

                originalPhones.add(phone);
            }

            values[4] = originalPhones;

        } catch (SQLException e) {
            if (e.getSQLState().equals(NO_ROW_SQL_STATE))
                throw new ErrorMessage("No such author exists");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        } finally {
            rollback();
        }
        return values;
    }

    /** Update stored information about a borrower
     *
     *  @param borrowerID the borrower ID of the borrower
     *  @param newLastName the new value of lastName (may be the same as original)
     *  @param newFirstName the new value of firstName (may be the same as original)
     *  @param originalPhones the original list of phone numbers for the borrower
     *         This will be a list of Strings, each one phone number
     *  @param newPhones the new list of phone numbers (may be the same as old)
     *         This will be a list of Strings, each one phone number
     *  @param newCategory the new value of category (may be the same as old)
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void updateBorrower(String borrowerID,
                                String newLastName,
                                String newFirstName,
                                List originalPhones,
                                List newPhones,
                                String newCategory) throws ErrorMessage {
        try {
            #sql { UPDATE Borrower
            SET last_name = :newLastName, first_name = :newFirstName, category_name = :newCategory
            WHERE borrower_id = :borrowerID
            };

            // Remove old list of phones
            Iterator oldPhonesIterator = originalPhones.iterator();
            while(oldPhonesIterator.hasNext()) {

                String number = (String) oldPhonesIterator.next();

                #sql { DELETE FROM Borrower_phone
                       WHERE Borrower_id = :borrowerID AND phone = :number
                };
            }

            Iterator phonesIterator = newPhones.iterator();
            while(phonesIterator.hasNext()) {

                String number = (String) phonesIterator.next();

                #sql { INSERT INTO Borrower_phone
                        values(:borrowerID, :number)
                };
            }
        }
        catch(SQLException e) {
            rollback();

            if (e.getErrorCode() == DUPLICATE_KEY_SQL_ERROR)
                // duplicate key error only occurs on Borrower_phone insertion
                throw new ErrorMessage("Duplicate phone for this borrower");
            else if (e.getMessage().indexOf(BORROWER_CATEGORY_FOREIGN_CONSTRAINT) >= 0)
                throw new ErrorMessage("Invalid category");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /** Delete a borrower
     *
     *  @param borrowerID the ID of the borrower to delete
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          the operation fails.  Any failure results in no changes being
     *          made to the database
     */
    public void deleteBorrower(String borrowerID) throws ErrorMessage
    {
        try
        {
            #sql { DELETE FROM Borrower
                        WHERE borrower_id = :borrowerID
                 };
          
            #sql { commit };
        }
        catch(SQLException e)
        {
            rollback();
            
            if (e.getSQLState().equals(NO_ROW_SQL_STATE))
                throw new ErrorMessage("No such borrower");
            else if (e.getErrorCode() == CANT_DELETE_BORROWER_WITH_BOOK_CHECKED_OUT)
                throw new ErrorMessage("This borrower has book(s) checked out");
            else
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /* ************************************************************************
     *  Methods called to manage fines
     * ***********************************************************************/

    /** Get a list of fines owed by a particular borrower
     *
     *  @param borrowerID the borrower whose fines are wanted
     *  @return a list of Fine objects - one for each fine the borrower owes
     *
     *  @exception an ErrorMessage is thrown with an appropriate message if
     *          there is no such borrower, or the borrower has no fines.
     */

    #sql iterator FineCursor(String, Date, Date, BigDecimal);

    public List getFines(String borrowerID) throws ErrorMessage
    {
        List result = new ArrayList();

        try
        {
            FineCursor cursor;

            // The compiler doesn't catch that the fetch below initializes
            // these variables, so give them default values now to keep the
            // compiler happy

            String title = null;
            Date dateDue = null;
            Date dateReturned = null;
            BigDecimal amount = null;

            #sql cursor = { select title, date_due, date_returned, amount
                                from fine
                                where borrower_id = :borrowerID
                                order by date_returned
                          };

            while(true)
            {
                #sql { fetch :cursor into :title,
                                          :dateDue,
                                          :dateReturned,
                                          :amount
                     };

                if (cursor.endFetch()) break;

                Fine fine = new Fine(title, dateDue, dateReturned, amount);

                result.add(fine);
            }
            cursor.close();
        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }

        if (result.size() == 0)
        {
            // No fines found - either the borrower doesn't exist, or has no fines
            // The following determines which is the case

            boolean borrowerExists;

            String dummy = null;
            try
            {
                #sql { select last_name into :dummy
                            from borrower
                            where borrower_id = : borrowerID };
                borrowerExists = true;
            }
            catch(SQLException e)
            {
                // If the above statement failed because no row was found,
                // this means the borrower doesn't exist

                if (e.getSQLState().equals(NO_ROW_SQL_STATE))
                    borrowerExists = false;
                else
                    throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
            finally
            {
                rollback();
            }

            if (borrowerExists)
                throw new ErrorMessage("This borrower has no fines");
            else
                throw new ErrorMessage("No such borrower");
        }
        else
            return result;
    }

    /** Record fine as paid.
     *
     *  @param borrowerID the ID of the borrower owing the fines
     *  @param fine the fine to be recorded as paid
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             recording the payment of the fine.
     */
    public void payFine(String borrowerID, Fine fine) throws ErrorMessage
    {
// IMPLEMENTED STUB (Implemented by EB)
        Date dateDue = fine.getDateDue();
        String book_title = fine.getValues()[0];
        String rowExists = "";

        // First we will verify that the row exists....
        try {
            #sql {  SELECT title
                    INTO :rowExists
                    FROM Fine
                    WHERE borrower_id = :borrowerID
                    AND title = :book_title
                    AND date_due = :dateDue };
            #sql { commit };
        } catch (SQLException e) {
            rollback();
            if (e.getMessage().contains("no rows found for select into statement")) {
                throw new ErrorMessage(NO_SUCH_FINE);
            } else {
                throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
            }
        }

        // Now we will delete the row
        try {
            #sql { DELETE FROM Fine
                    WHERE borrower_id = :borrowerID
                    AND title = :book_title
                    AND date_due = :dateDue };
            #sql { commit };
        } catch (SQLException e) {
            rollback();
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
    }

    /* ************************************************************************
     * Methods called to produce various kinds of report
     * ***********************************************************************/

    /** Produce a list of all books - call number, title, author(s), format,
     *  number of copies owned
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */

    #sql iterator BooksReportCursor(String, String, String, String, int);

    public void booksReport(PrintStream stream) throws ErrorMessage
    {
        try
        {
            BooksReportCursor cursor;

            // Left joins are used to ensure we include Book_info even if there
            // is no author or copy recorded
            #sql cursor = { select Book_info.call_number,
                                   title,
                                   author_name,
                                   format,
                                   count(copy_number)
                                from Book_info left join Book_author
                                on Book_info.call_number = Book_author.call_number
                                left join Book
                                on Book_info.call_number = Book.call_number
                                group by Book_info.call_number,
                                         title,
                                         author_name,
                                         format
                                order by Book_info.call_number
                           };

            String [] BOOKS_REPORT_HEADINGS =
                { "Call Number", "Title", "Author", "Format", "# copies" };
            int [] BOOKS_REPORT_COLUMN_WIDTHS =
                { 22, 52, 22, 4, 5 };
            boolean [] BOOKS_REPORT_REPEAT_COLUMNS =
                { true, true, false, true, true };

            produceReport(stream,
                          "Book Information Report",
                          BOOKS_REPORT_HEADINGS,
                          BOOKS_REPORT_COLUMN_WIDTHS,
                          BOOKS_REPORT_REPEAT_COLUMNS,
                          cursor.getResultSet());

            cursor.close();

        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }
    }

    /** Produce a list of all copies of books - bar code, call number,
     *  copy number and title
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */
    #sql iterator BookCopyReportCursor(String, String, int, String);

    public void bookCopiesReport(PrintStream stream) throws ErrorMessage
    {
        try {
            BookCopyReportCursor cursor;

            // Left joins are used to ensure we include Book_info even if there
            // is no author or copy recorded
            #sql cursor = { select bar_code, book.call_number, copy_number, title
                            from book
                            join
                            book_info
                            on book.call_number = book_info.call_number
                            };

          String [] BOOKS_COPIES_REPORT_HEADINGS = { "Bar Code", "Call Number", "Copy #", "Title" };
          int [] BOOKS_COPIES_REPORT_COLUMN_WIDTHS = { 13, 22, 8, 50 };
          boolean [] BOOKS_COPIES_REPORT_REPEAT_COLUMNS = { false, false, false, false };

          produceReport(stream,
                        "Book Copies Report",
                        BOOKS_COPIES_REPORT_HEADINGS,
                        BOOKS_COPIES_REPORT_COLUMN_WIDTHS,
                        BOOKS_COPIES_REPORT_REPEAT_COLUMNS,
                        cursor.getResultSet());
          cursor.close();

        } catch(SQLException e) {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        } finally {
            rollback();
        }
    }

    /** Produce a keywords report - keywords listed in alphabetical order,
     *  together with the call number and title of each book having that keyword
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */
    #sql iterator KeywordReportCursor(String, String, String);
    public void keywordsReport(PrintStream stream) throws ErrorMessage
    {
        // STUB (Implemented by JC)
        try {
          KeywordReportCursor cursor;
          #sql cursor = { select keyword, book_keyword.call_number, title
                          from book_keyword
                          join
                          book_info
                          on book_keyword.call_number = book_info.call_number
                          order by keyword, book_keyword.call_number
                          };

          String [] BOOKS_KEYWORD_REPORT_HEADINGS = { "Keyword", "Call Number", "Title" };
          int [] BOOKS_KEYWORD_REPORT_COLUMN_WIDTHS = { 22, 22, 50 };
          boolean [] BOOKS_KEYWORD_REPORT_REPEAT_COLUMNS = { false, false, false };

        produceReport(stream,
                      "Book Keywords Report",
                      BOOKS_KEYWORD_REPORT_HEADINGS,
                      BOOKS_KEYWORD_REPORT_COLUMN_WIDTHS,
                      BOOKS_KEYWORD_REPORT_REPEAT_COLUMNS,
                      cursor.getResultSet());
        cursor.close();

        } catch(SQLException e) {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        } finally {
            rollback();
        }
    }


    /** Produce a list of all categories - name, max books out, checkout period
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */

    #sql iterator CategoryReportCursor(String, int, int);

    public void categoriesReport(PrintStream stream) throws ErrorMessage
    {
        try
        {
            CategoryReportCursor cursor;

            #sql cursor = { select * from category order by category_name };

            String [] CATEGORY_REPORT_HEADINGS =
                { "Category Name", "Checkout Period", "Maximum Books Out" };
            int [] CATEGORY_REPORT_COLUMN_WIDTHS =
                { 15, 17, 10 };

            produceReport(stream,
                          "Categories Report",
                          CATEGORY_REPORT_HEADINGS,
                          CATEGORY_REPORT_COLUMN_WIDTHS,
                          null,
                          cursor.getResultSet());

            cursor.close();

        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }
    }

    /** Produce a list of all borrowers - id, name, phone number(s), category
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */

    #sql iterator BorrowersReportCursor(String, String, String, String, String);

    public void borrowersReport(PrintStream stream) throws ErrorMessage
    {
        // STUB IMPLEMENTED BY JC
        try
        {
            BorrowersReportCursor cursor;

            #sql cursor = { select borrower_phone.borrower_id, last_name, first_name, phone, category_name
                            from borrower
                            join
                            borrower_phone
                            on borrower.borrower_id = borrower_phone.borrower_id
                            order by borrower_phone.borrower_id};

            String [] BORROWERS_REPORT_HEADINGS =
                  { "Borrower ID", "Last Name", "First Name", "Phone #", "Category" };
              int [] BORROWERS_REPORT_COLUMN_WIDTHS =
                  { 12, 22, 22, 22, 10 };
              boolean [] BORROWERS_REPORT_REPEAT_COLUMNS =
                  { true, true, true, false, true };

            produceReport(stream,
                          "Borrowers Report",
                          BORROWERS_REPORT_HEADINGS,
                          BORROWERS_REPORT_COLUMN_WIDTHS,
                          BORROWERS_REPORT_REPEAT_COLUMNS,
                          cursor.getResultSet());
            cursor.close();

        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }
    }

    /** Produce a list of all fines outstanding - borrower name and
     *  phone number(s), total of all fines outstanding for this borrower
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */
    #sql iterator FinesReportCursor(String, String, String, float);
    public void finesReport(PrintStream stream) throws ErrorMessage
    {
        // STUB IMPLEMENTED BY JC
        try
        {
            FinesReportCursor cursor;

            #sql cursor = { select last_name, first_name, phone, sum(amount)
              from fine
              join borrower
              on fine.borrower_id = borrower.borrower_id
              join borrower_phone
              on fine.borrower_id = borrower_phone.borrower_id
              group by last_name, first_name, phone
              order by sum(amount) desc };

            String [] FINES_REPORT_HEADINGS =
                { "Last Name", "First Name", "Phone #", "Total Fines" };
            int [] FINES_REPORT_COLUMN_WIDTHS =
                { 22, 22, 22, 11 };
            boolean [] FINES_REPORT_REPEAT_COLUMNS =
                { true, true, false, true };

            produceReport(stream,
                          "Fines Report",
                          FINES_REPORT_HEADINGS,
                          FINES_REPORT_COLUMN_WIDTHS,
                          FINES_REPORT_REPEAT_COLUMNS,
                          cursor.getResultSet());
            cursor.close();

        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }
    }


    /** Produce a list of all overdue books - borrower name,
     *  title(s) of overdue books with due date for each.
     *
     *  @param stream the stream to which to print the report
     *
     *  @exception an ErrorMessage is thrown if there is an unexpected error
     *             accessing the database.
     */
    #sql iterator OverdueReportCursor(String, String, String, String);
    public void overdueBooksReport(PrintStream stream) throws ErrorMessage
    {
        // STUB IMPLEMENTED BY JC
        try
        {
            OverdueReportCursor cursor;

            #sql cursor = { select last_name, first_name, title, date_due
                            from fine
                            join 
                            borrower
                            on fine.borrower_id = borrower.borrower_id
                            order by last_name, first_name, date_due };

            String [] OVERDUE_BOOKS_REPORT_HEADINGS =
                { "Last Name", "First Name", "Title", "Date Due" };
            int [] OVERDUE_BOOKS_REPORT_COLUMN_WIDTHS =
                { 22, 22, 52, 10 };
            boolean [] OVERDUE_BOOKS_REPORT_REPEAT_COLUMNS =
                { true, true, false, false };

            produceReport(stream,
                          "Overdue Books Report",
                          OVERDUE_BOOKS_REPORT_HEADINGS,
                          OVERDUE_BOOKS_REPORT_COLUMN_WIDTHS,
                          OVERDUE_BOOKS_REPORT_REPEAT_COLUMNS,
                          cursor.getResultSet());
            cursor.close();

        }
        catch(SQLException e)
        {
            throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
            rollback();
        }
    }


    /* ************************************************************************
     * Utility methods
     * ***********************************************************************/

    /** Roll back a read-only transaction or a failed write transaction
     *
     */
    private void rollback()
    {
        try
        {
            #sql { rollback };
        }
        catch(SQLException e)
        {
            System.out.println("Fatal error: SQL Exception " + e.getErrorCode() +
                " " + e.getMessage() + " during rollback. ");
            System.exit(1);
        }
    }

    /** Print a neatly formatted report
     *
     *  @param stream the stream to print the report to
     *  @param heading the overall heading for the report
     *  @param columnHeaadings the headings for the report's columns
     *  @param columnWidths the widths for the various columns
     *  @param repeatColumns for some report formats, certain values need to
     *         be suppressed for all but their first occurrence if the exact
     *         same values occur on successive lines of the report.  This
     *         array specifies which columns these are.  If _all_ of the
     *         columns specified contain the exact same values on
     *         successive lines, the values will be replaced by spaces on all
     *         but the first line.  This parameter can be null if this feature
     *         is not used for a certain report
     *  @param resultSet a SQL result set containing the report's data
     */
    private void produceReport(PrintStream stream,
                               String heading,
                               String [] columnHeadings,
                               int [] columnWidths,
                               boolean [] repeatColumns,
                               ResultSet resultSet) throws SQLException
    {
        stream.println(); stream.println(heading);
        for (int i = 0; i < heading.length(); i ++)
            stream.print('_');
        stream.println(); stream.println();

        for (int i = 0; i < columnHeadings.length; i ++)
            stream.print(pad(columnHeadings[i], columnWidths[i]));
        stream.println();
        for (int i = 0; i < columnHeadings.length; i ++)
        {
            for (int j = 0; j < columnHeadings[i].length(); j ++)
                stream.print('_');
            stream.print(pad("", columnWidths[i] - columnHeadings[i].length()));
        }
        stream.println(); stream.println();

        String [] previousLineValues = new String [columnHeadings.length];

        while(resultSet.next())
        {
            String [] currentLineValues = new String [columnHeadings.length];
            boolean repeatValuesSame = repeatColumns != null;

            for (int i = 0; i < currentLineValues.length; i ++)
            {
                currentLineValues[i] = resultSet.getString(i + 1);
                if (repeatValuesSame && repeatColumns[i] &&
                        ! currentLineValues[i].equals(previousLineValues[i]))
                    repeatValuesSame = false;
            }

            for (int i = 0; i < currentLineValues.length; i ++)
            {
                if (repeatValuesSame && repeatColumns[i])
                    stream.print(pad("", columnWidths[i]));
                else
                    stream.print(pad(currentLineValues[i], columnWidths[i]));
            }

            stream.println();
            previousLineValues = currentLineValues;
        }
        stream.println(); stream.println();
    }

    /** Pad a string with spaces
     *
     *  @param input the string to pad.  Can be null - in which case it will
     *         be converted to an empty string
     *  @param width the total width to pad it to
     *  @return the string padded with enough spaces to make the specified width.
     *          If the string was wider than width to begin with, it is returned
     *          unchanged
     */
    private static String pad(String input, int width)
    {
        if (input == null) input = "";
        StringBuffer result = new StringBuffer(input);
        while(result.length() < width)
            result.append(' ');
        return result.toString();
    }

    /* ************************************************************************
     * To facilitate testing, the database maintains a variable called today
     * that can be altered from a menu.  The following methods support this
     * facility.
     * THEY ARE ONLY HERE TO SUPPORT THE "DIDDLE WITH DATE" OPTION IN THE
     * "TEST" MENU.   THEY SHOULD NEVER BE CALLED FROM STUDENT CODE!
     * ***********************************************************************/

	/** Reset today to the current date
	 */
	public void resetToday() throws ErrorMessage
	{
		try
		{
			// Must use dynamic sql for this because version of sqlj
			// being used does not support set for global variables
			connection.createStatement().executeUpdate("set today = current date");
		}
        catch(SQLException e)
        {
        	throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
        	rollback();
        }
	}

	/** Adjust the value of today forward a backward
	 *
	 *	@param amount the amount to change (forward if >0; backward if < 0)
	 */
	public void changeToday(int amount) throws ErrorMessage
	{
		try
		{
			// Must use dynamic sql for this because version of sqlj
			// being used does not support set for global variables
			connection.createStatement().executeUpdate(
				"set today = today + " + amount);
		}
        catch(SQLException e)
        {
        	throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
        	rollback();
        }
	}

	/** Get the current value of today
	 *
	 *  @return the current value of today
	 */
	public java.sql.Date getToday() throws ErrorMessage
	{
		try
		{
			java.sql.Date result;
			#sql { select today into :result from sysibm.sysdummy1 };
			return result;
		}
        catch(SQLException e)
        {
        	throw new ErrorMessage("Unexpected SQL error " + e.getMessage());
        }
        finally
        {
        	rollback();
        }
	}

	Connection connection;

    /* ************************************************************************
     * Class constants and method
     * ***********************************************************************/

    // Symbolic names for various SQL Errors

    private static final int BAD_PASSWORD_SQL_ERROR = -1403;
    private static final String NO_ROW_SQL_STATE = "02000";
    private static final int DUPLICATE_KEY_SQL_ERROR = -803;
    private static final int CANT_DELETE_BORROWER_WITH_BOOK_CHECKED_OUT = 70001;
    private static final int NON_EXISTENT_PARAMETER = -302;

    private static final String BOOK_INFO_VALID_FORMAT_CONSTRAINT =
        "The format entered is not allowable. Allowable values for the " +
        "format include: HC, SC, CD, MF, or PE.";
    private static final String BOOK_KEYWORD_VALID_KEYWORD_CONSTRAINT =
        "FK_Book_Keyword";
    private static final String BORROWER_CATEGORY_FOREIGN_CONSTRAINT =
        "FK_Borrower_Category";
    private static final String NO_SUCH_BOOK =
        "Sorry, the book specified does not exist";
    private static final String NO_SUCH_BORROWER =
        "Sorry, the borrower specified does not exist";
    private static final String CANT_RENEW_OVERDUE_MSG =
        "Sorry this book is overdue and cannot be renewed";
    private static final String DUPLICATE_ENTRY_ERROR =
        "Sorry this row contains a duplicate of an existing value(s) in the table" +
        " that is specified as unique or is the primary key.";
    private static final String MAX_BOOKS_ALREADY_OUT_MSG =
        "Sorry this borrower already has the maximum books checked out " +
        "for their category.";
    private static final String NO_SUCH_FINE =
        "Sorry, the fine you are attempting to pay does not exist.";

    private static final String BOOK_AUTHOR_TABLE_NAME = "BOOK_AUTHOR";

    private static final String DRIVER_NAME = "com.ibm.db2.jcc.DB2Driver";
    private static final String DATABASE_URL =
    	"jdbc:db2://localhost:50000/project";

    // For testing purposes only - display an array of values for fields that
    // are parameters to a method

    private String toString(Object [] information)
    {
        String result = "";
        for (int i = 0; i < information.length; i ++)
        {
            if (information[i] instanceof String)
                result += (String) information[i];
            else
            {
                Iterator iterator = ((List) information[i]).iterator();
                if (iterator.hasNext())
                {
                    String separator = "{ ";
                    while (iterator.hasNext())
                    {
                        result += separator += (String) iterator.next();
                        separator = ", ";
                    }
                    result += " }";
                }
                else
                    result += "{}";
            }
            if (i < information.length - 1)
                result += ", ";
        }
        return result;
    }
}
